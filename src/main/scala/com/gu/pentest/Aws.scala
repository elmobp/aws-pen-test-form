package com.gu.pentest

import java.util.{Timer, TimerTask}

import com.amazonaws.auth.AWSCredentials
import com.amazonaws.auth.AWSCredentialsProvider
import com.amazonaws.auth.AWSCredentialsProviderChain
import com.amazonaws.auth.DefaultAWSCredentialsProviderChain
import com.amazonaws.auth.EnvironmentVariableCredentialsProvider;
import com.amazonaws.auth.InstanceProfileCredentialsProvider;
import com.amazonaws.auth.Presigner;
import com.amazonaws.auth.Signer;
import com.amazonaws.auth.SignerFactory;
import com.amazonaws.auth.SystemPropertiesCredentialsProvider;
import com.amazonaws.regions.Region
import com.amazonaws.services.autoscaling.AmazonAutoScalingAsyncClient
import com.amazonaws.services.autoscaling.model.{DescribeAutoScalingGroupsRequest, DescribeAutoScalingGroupsResult}
import com.amazonaws.services.ec2.AmazonEC2AsyncClient
import com.amazonaws.services.ec2.model.{DescribeInstancesRequest, DescribeInstancesResult}
import com.gu.pentest.util.AwsTools

import scala.collection.JavaConversions._
import scala.concurrent.duration.Duration
import scala.concurrent.{Future, Promise}
import scala.util.Success


object Aws {
  def getCredentials(profileName: String): AWSCredentials =
  new AWSCredentialsProviderChain(
                new EnvironmentVariableCredentialsProvider(),
                new SystemPropertiesCredentialsProvider(),
                new InstanceProfileCredentialsProvider()).getCredentials
  // EC2

  def ec2Client(credentials: AWSCredentials, region: Region): AmazonEC2AsyncClient = {
    val client = new AmazonEC2AsyncClient(credentials)
    client.setRegion(region)
    client
  }

  def describeInstances(ec2Client: AmazonEC2AsyncClient, request: DescribeInstancesRequest = new DescribeInstancesRequest()
    ): Future[DescribeInstancesResult] = {
    AwsTools.asFuture(ec2Client.describeInstancesAsync)(request)
  }

  // Autoscaling

  def asClient(credentials: AWSCredentials, region: Region): AmazonAutoScalingAsyncClient = {
    val client = new AmazonAutoScalingAsyncClient(credentials)
    client.setRegion(region)
    client
  }

  def describeAutoScalingGroups(asClient: AmazonAutoScalingAsyncClient, request: DescribeAutoScalingGroupsRequest = new DescribeAutoScalingGroupsRequest): Future[DescribeAutoScalingGroupsResult] = {
    AwsTools.asFuture(asClient.describeAutoScalingGroupsAsync)(request)
  }

  // Tools
  val ineligbleInstanceTypes = Set("t1.micro", "m1.small", "t2.nano")

  def getInstances(instancesResult: DescribeInstancesResult): List[PenTestInstance] = {
    instancesResult.getReservations.toList.flatMap { reservation =>
      reservation.getInstances.toList.flatMap { instance =>
        for {
          id <- Option(instance.getInstanceId)
          ip <- Option(instance.getPublicIpAddress).orElse(Option(instance.getPrivateIpAddress))
          instanceType <- Option(instance.getInstanceType)
        } yield PenTestInstance(id, ip, instanceType)
      }
    }
  }

  def getAsGroups(asGroupsResult: DescribeAutoScalingGroupsResult): List[PenTestAsGroup] = {
    asGroupsResult.getAutoScalingGroups.toList.map { asGroup =>
      val name = asGroup.getAutoScalingGroupName
      val instanceIds = asGroup.getInstances.toList.map(_.getInstanceId)
      PenTestAsGroup(name, instanceIds)
    }
  }

  def getPenTestDetails(asGroups: List[PenTestAsGroup], instances: List[PenTestInstance]): Map[String, List[PenTestInstance]] = {
    val validInstances = instances.filter(validInstanceType)
    val validInstanceIds = validInstances.map(_.id)

    (for {
      asGroup <- asGroups
        if asGroup.instanceIds.exists(validInstanceIds.contains)
      instanceId <- asGroup.instanceIds
      validAsGroupInstances = validInstances.filter(instance => asGroup.instanceIds.contains(instance.id))
    } yield asGroup.name -> validAsGroupInstances).toMap
  }

  def warnings(asGroups: List[PenTestAsGroup], instances: List[PenTestInstance]): Map[PenTestAsGroup, List[PenTestInstance]] = {
    val invalidInstances = instances.filterNot(validInstanceType)
    val invalidInstanceIds = invalidInstances.map(_.id)

    (for {
      asGroup <- asGroups
        if asGroup.instanceIds.exists(invalidInstanceIds.contains)
    } yield {
      asGroup -> invalidInstances.filter(instance => asGroup.instanceIds.contains(instance.id))
    }).toMap
  }

  def validInstanceType(instance: PenTestInstance): Boolean = {
    !ineligbleInstanceTypes.contains(instance.instanceType)
  }
}
