package com.gu.pentest

import org.scalatest.concurrent.ScalaFutures
import org.scalatest.time.{Millis, Seconds, Span}
import org.scalatest.{BeforeAndAfterAll, FreeSpec, Matchers, OptionValues}

class AwsTest extends FreeSpec with Matchers with OptionValues with ScalaFutures with BeforeAndAfterAll {
  implicit val defaultPatience =
    PatienceConfig(timeout = Span(5, Seconds), interval = Span(500, Millis))

  val instance1 = PenTestInstance("id1", "1.1.1.1", "t2.medium")
  val instance2 = PenTestInstance("id2", "1.1.1.2", "t2.medium")
  val instance3 = PenTestInstance("id3", "1.1.1.3", "t2.medium")
  val nano = PenTestInstance("id-nano", "1.1.1.4", "t2.nano")
  val t1Micro = PenTestInstance("id-micro", "1.1.1.5", "t1.micro")
  val m1Small = PenTestInstance("id-small", "1.1.1.6", "m1.small")

  "getPenTestDetails" - {
    "returns an empty map if there are no AS groups" in {
      Aws.getPenTestDetails(Nil, Nil) shouldEqual Map.empty
    }

    "works for this example" in {
      val instances = List(instance1, instance2, instance3)
      val asGroups = List(
        PenTestAsGroup("as1", List("id1", "id2")),
        PenTestAsGroup("as2", List("id3"))
      )
      Aws.getPenTestDetails(asGroups, instances) shouldEqual Map(
        "as1" -> List(instance1, instance2),
        "as2" -> List(instance3)
      )
    }

    "does not include AS groups with no instances" in {
      val instances = List(instance1)
      val asGroups = List(
        PenTestAsGroup("as1", List("id1")),
        PenTestAsGroup("as2", List("not-an-instance"))
      )
      val result = Aws.getPenTestDetails(asGroups, instances)
      result should contain key "as1"
      result shouldNot contain key "as2"
    }

    "excludes t2.nano instance types" in {
      val instances = List(instance1, nano)
      val asGroups = List(PenTestAsGroup("as1", instances.map(_.id)))
      Aws.getPenTestDetails(asGroups, instances).get("as1").value.map(_.instanceType) should not contain "t2.nano"
    }

    "excludes m1.small instance types" in {
      val instances = List(instance1, m1Small)
      val asGroups = List(PenTestAsGroup("as1", instances.map(_.id)))
      Aws.getPenTestDetails(asGroups, instances).get("as1").value.map(_.instanceType) should not contain "m1.small"
    }

    "excludes t1.micro instance types" in {
      val instances = List(instance1, t1Micro)
      val asGroups = List(PenTestAsGroup("as1", instances.map(_.id)))
      Aws.getPenTestDetails(asGroups, instances).get("as1").value.map(_.instanceType) should not contain "t1.micro"
    }

    "excludes as groups that contain only excluded instance types" in {
      val instances = List(m1Small, t1Micro)
      val asGroups = List(PenTestAsGroup("as1", instances.map(_.id)))
      Aws.getPenTestDetails(asGroups, instances) shouldBe 'empty
    }
  }

  "warnings" - {
    "does not include an AS group with no invalid instances" in {
      val instances = List(instance1, instance2)
      val asGroups = List(PenTestAsGroup("as1", instances.map(_.id)))
      Aws.warnings(asGroups, instances) shouldEqual Map.empty
    }

    "given an AS group with invalid instances" - {
      val instances = List(instance1, nano, t1Micro)
      val asGroup = PenTestAsGroup("as1", instances.map(_.id))

      "includes that group in its returned groups" in {
        Aws.warnings(List(asGroup), instances).keySet.map(_.name) should contain("as1")
      }

      "returns all invalid instances for an AS group" in {
        val invalidInstances = Aws.warnings(List(asGroup), instances).get(asGroup).value
        invalidInstances should contain(nano)
        invalidInstances should contain(t1Micro)
      }

      "does not include valid instances in the warnings" in {
        val invalidInstances = Aws.warnings(List(asGroup), instances).get(asGroup).value
        invalidInstances shouldNot contain(instance1)
      }
    }
  }
}
